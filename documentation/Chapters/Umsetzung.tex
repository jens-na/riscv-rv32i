\iffalse
\TODO: RAM im code umbenennen
\TDOD: Probleme: RAM
\TODO: Komponente Main
\TODO: Probleme: ALU und Decode erst clk-sensitiv implementiert
\TODO: maschinenbefehle durchgehen: wurde etwas besonders implementiert?
\TODO: warum zwei Takte?
\TODO: latches
\TODO: synchrones design
\TODO: Register erklären?
\TODO: ALU zero-flag-next entfernen
\TODO: ELF, 
\fi

\chapter{Umsetzung} % Main chapter title
\label{Umsetzung} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------
\section{Komponenten der CPU}

%\begin{figure}
%
%    \includegraphics[scale=0.3, angle=90]{Figures/dia.jpg}
%\end{figure}


\iffalse
- Diagramm 
- sukzessive Entwicklung, per Maschinenbefehl
\fi
\subsection{Decode}



In dieser Komponente wird der aktuelle Maschinenbefehl, nachdem er aus dem Speicher geladen wurde, dekodiert und die daraus gewonnenen Informationen werden über Steuersignale an die jeweiligen Einheiten der CPU übertragen:
\begin{itemize}
    \item Die \textit{Registerbank} bekommt mitgeteilt, welche Registerinhalte sie an ihre Ausgänge anlegen soll und in welches Register ein potentielles Ergebnis geschrieben werden muss.
        Außerdem wird über einen \textit{Multiplexer} gesteuert, ob dieses Ergebnis vom \textit{Program Counter}, dem \textit{Hauptspeicher} oder der \textit{ALU} zu erwarten ist.
    \item An die \textit{ALU} wird der Operationstyp übermittelt, den diese auf ihre beiden Operanden anwenden soll.
        Zusätzlich wird auch hier ein Multiplexer angesteuert, der der ALU entweder einen Registerinhalt oder eine Konstante als zweiten Operanden zuweist.
    \item Der \textit{Hauptspeicher} erhält Informationen über die Bitbreite und die Art eines Speicherzugriffs (lesend/schreibend).
    \item Der Wert des \textit{Program Counters} muss bei Sprungbefehlen angepasst werden.
\end{itemize}
Es werden also alle Informationen, die zur Ausführung eines Maschinenbefehls nötig sind, von der Dekodiereinheit extrahiert und an die zugehörige Stelle übertragen. 

Bei der Umsetzung dieser Aufgabe erweist sich der Aufbau der Maschinenbefehle als sehr hilfreich:
Vergleichbare Informationen belegen innerhalb der 32-Bit- Instruktionen die gleichen Positionen.
Enthält ein Maschinenbefehl z.B. ein Zielregister in das ein Ergebnis geschrieben werden soll, so befindet sich die Adresse dieses Zielrgisters an der gleichen Position, an der es sich auch bei anderen Befehlen befindet.
Das erleichtert zum einen die Implementierung, da einem Ausgangsport über mehrer Befehle hinweg die gleichen Bits zugeordnet werden können und verringert zum anderen die Komplexität der daraus resultierenden Schaltungen. 
Ein Blick in den Quellcode (siehe~\ref{}) zeigt, dass eine verschachtelte \textit{Case}-Abfrage den Ausgangsports die passenden Signale zuweist, die ohne den vorteilhaften Aufbau der Maschinenbefehle wesentlich komplexer geraten wäre.

\subsection{Program Counter}

Beim sog. \textit{Program Counter} (kurz: \textit{PC}) handelt es sich um ein flankengesteuertes 32-Bit-Register mit asynchronem Reset, das die Adresse enthält, unter der der nächste abzuarbeitende Maschinenbefehl im Hauptspeicher zu finden ist. 
Wie der Name schon vermuten lässt, ist der PC als Zählregister implementiert:
Alle zwei Takte wird der aktuelle Registerwert um vier erhöht, um damit den nächsten 32-Bit-Maschinenbefehl zu adressieren.
Ein Flag (\textit{enable}), das nur alle zwei Takte gesetzt ist, verhindert, dass dieser Vorgang jeden Takt zur Ausführung kommt.

Soll ein Sprungbefehl ausgeführt werden, muss der Wert des PCs auf eine neue Adresse gesetzt oder ein Offset auf den aktuellen Zählerstand addiert werden.
Beide Funktionialitäten wurden direkt im PC implementiert, um einen Umweg über die \textit{ALU} zu vermeiden.
Hierfür stehen die Eingangsports \textit{set}, \textit{set\_value} und \textit{set\_jalr} zur Verfügung.

Am Ausgangsport \textit{value\_out\_next} liegt die Adresse des nächsten Maschinenbefehls (\textit{PC + 4}) an, die als Rücksprungadresse optional in der Registerbank abgespeichert werden kann, um zu einem späteren Zeitpunkt zum ürsprünglichen Ausführungsstrang zurückzukehren.

Die Implementierung des Program Counters unterliegt den Prinzipien des \textit{synchronen Designs} (siehe~\ref{})...

\subsection{Registerbank}

Bevor die CPU eine Rechenoperationen durchführen kann, müssen die passenden Operanden aus dem Hauptspeicher geladen und in der \textit{Registerbank} zwischengespeichert werden.
Diese besteht aus 32 Registern der Länge 32 Bit, wobei es sich bei der vorliegenden Implementierung eigentlich um ein Array aus nur 31 Registern handelt, da das \textit{Register 0} konstant den Wert $0$ enthält und nicht überschrieben werden kann.

Ein asynchroner Leseprozess versorgt die beiden Datenausgänge mit den Inhalten der beiden Register, die durch die Eingänge \textit{rs1} und \textit{rs2} ausgewählt werden.
Beide Ausgänge leiten die Werte an die ALU weiter, während eine zusätzliche Verbindung zum RAM die Ausführung einer \textit{Store}-Instruktion erleichtert.
Ein Schreibprozess in das Register mit dem Index \textit{rd} ist nur bei steigender Taktflanke und gleichzeitig gesetztem Eingangsport \textit{en\_write} möglich, womit ein ungewolltes Speichern verhindert wird.
Der Dateneingang kann mittels eines vorgeschalteten Multiplexers Werte aus den RAM, der ALU oder dem PC empfangen.



\subsection{Arithmetisch Logische Einheit}

Die eigentlichen Rechenoperationen werden in der arithmetisch-logischen Einheit (kurz: \textit{ALU} für \textit{arithmetic logic unit}) durchgeführt.
Wie der Name bereits andeutet, führt diese Einheit arithmetische und logische Funktionen auf zwei 32-Bit-Zahlen aus (siehe Übersicht~\ref{}).
Neben den beiden Dateneingängen enthält die ALU einen weiteren Eingang(\textit{op\_in}), über den sie von der Decode-Einheit den auszuführenden Funktionstypen erhält.
Das Ergebnis der Berechnung wird, abhängig vom Maschinenbefehl, entweder an die Registerbank, den Hauptspeicher oder den Program Counter weitergeleitet.
%TODO: zero_flag
Ein weiterer Ausgangsport (\textit{zero\_flag}) versorgt die Dekodiereinheit bei bedingten Sprungbefehlen mit der Information, ob ein Sprung genommen werden muss. 

Bei der Implementierung wurde eine einfache \textit{Case}-Anweisung verwendet, die den Funktionstypen abfragt, woraufhin die entsprechende Funktion zur Anwendung kommt.

\subsection{Random Access Memory}

Im \textit{RAM} (kurz für: \textit{Random Access Memory}, auch \textit{Hauptspeicher} genannt), werden die Maschinenbefehle und sonstige, zur Programmausführung benötigte Daten, abgelegt.

Grundsätzlich unterschiedet man zwei Arten von RAM, die implementiert werden können:
\textit{Distributed RAM} greift auf die Look-Up-Tables und Logigblöcke des FPGAs zu, während es sich beim \textit{Block RAM} um ein internes Speichermodul des FPGAs handelt.
Für welchen Typ man sich entscheidet hängt von vielen Faktoren ab, auf die hier nicht im Detail eingegangen werden soll. 
Grundsätzlich sollte man eher Block RAM verwenden, wenn man viel Speicherplatz benötigt, um keine Logikzellen zu belegen.
Distributed RAM dagegen kann flexibler konfiguriert werden. 
Für die Erstellung von RAM gibt es eine Reihe von vorgegebenen Templates an die man sich halten sollte, wenn man sicherstellen möchte, dass die Synthese das gewünschte Ergebnis liefert.~\cite[S. 243 ff.]{Chu}
Bei resourcen- und zeitkritischeren Projekten bedarf die Entscheidung, welchen Art von RAM man letztendlich verwendet, sicherlich einer eingehenden Analyse, bei der vorliegenden Implementierung war dies allerdings nicht notwendig.

In diesem Fall wurde der Hauptspeicher als \textit{Dual-Port RAM} mit \textit{asynchronem Lesezugriff} konfiguriert, was von den Synthesetools automatisch als Distributed RAM erkannt und umgesetzt wird.
Der Begriff Dual-Port bezieht sich auf zwei Datenausgangsports, in diesem Fall einem Ausgang für den aktuellen Maschinenbefehl (\textit{instr\_out}) und einem Datenausgang (\textit{data\_out}).
Die ansychronen Ausgänge haben den Vorteil, dass die Daten bei einem Lesezugriff nach einer kurzen Verzögerung zur Verfügung stehen, anstatt einen weiteren Takt darauf warten zu müssen.
Der Schreibzugriff ist, ähnlich wie bei der Registerbank, taktflankengesteuert und von einem zusätzlichen Flag abhängig.
%TODO: Größe RAM

\paragraph{RAM-Control.} Der RISC-V-Instruktionssatz sieht eine Byte-Adressierung für den Hauptspeicher vor, d.h. mit einer Speicheradresse ist es möglich genau ein Byte zu adressieren.
Zusätzlich erfordern bestimmte Instruktionen, wie z.B. \textit{load halfword} oder \textit{load word} einen Zugriff auf 16 oder 32 Bit.
Möchte man diese Unterscheidung der Bitbreite eines Zugriffs direkt im RAM implementieren, läuft man Gefahr, dass das Ergebnis nicht mehr dem vorgegebenen Template entspricht und der RAM bei der Synthese nicht mehr als solcher erkannt wird.
Aus diesem Grund wurde eine zusätzliche \textit{RAM-Control}-Einheit erstellt, die die Zugriffslogik abstrahiert und sicherstellt, dass auf den Hauptspeicher nur mit der Breite von 32 Bit zugegriffen wird.

\paragraph{Adressierung.} Wird nun ein bestimmtes Byte im Speicher adressiert, muss die Kontrolleinheit die Originaladresse durch vier teilen um die Adresse des zugehörigen Wortes im RAM zu erhalten. 
Dieses Wort wird anschließend gelesen und über die beiden niederwertigsten Bits der ursprünglichen Adresse extrahiert man das passende Byte.
Bei einem Lesezugriff wird dieses Byte nun in die acht niederwertigsten Bits des Datenausgangs gepackt, abhängig von der Instruktion und dem Vorzeichen des Bits mit Nullen oder Einsen aufgefüllt und an die Registerbank weitergeleitet.
Wird auf den Speicher schreibend zugegriffen, wird das jeweilige Byte des gelesenen Wortes ersetzt und anschließend das veränderte Wort in den Speicher zurückgeschrieben.
Dieses Vorgehen kann natürlich auch auf Halbwort-Zugriffe übertragen werden.

\paragraph{Beispiel:}
Angenommmen das Wort 0x00184421 befindet sich im Hauptspeicher an der Adresse 0x2 und es erfolgt ein Zugriff auf das Byte an der Adresse 0xa.
Da sich die Adresse 0xa auf eine Byteadressierung bezieht wird diese von der Kontrolleinheit durch vier geteilt um an das richtige Wort im Speicher zu kommen.
Unter der resultierenden Adresse 0x2 wird folglich das Wort 0x00184421 gelesen.
Über die niederwertigsten Bits der ursprünglichen Adresse ($10_2$) extrahiert man das passende Byte 0x18 aus diesem Wort.
Handelt es sich um einen Lesezugriff wird dieses Byte zu dem Wort 0x00000018 aufgefüllt und an den Datenausgang angelegt.
Bei einem Schreibzugriff wird das Byte 0x18 im ursprünglichen Wort ersetzt (z.B. durch 0xff) und das modifizierte Wort (in diesem Fall also 0x00ff4421) wieder an die Adresse 0x2 in den Speicher geschrieben.


%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Entwicklungsumgebung}
\subsection{Vivado}
\subsection{Entwicklungsworkflow}
\subsubsection{Simulation}
\subsubsection{Synthese und Implementierung}
\subsubsection{Deviceprogrammierung}
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
\section{Details der Implementierung}
Hier: Erreichte Taktrate, Benötigte Taktzyklen pro
Instruktion, Laufzeiten.. ??
%----------------------------------------------------------------------------------------
