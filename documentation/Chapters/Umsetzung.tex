\iffalse
\TDOD: Probleme: BRAM
\TODO: Komponente Main
\TODO: Probleme: ALU und Decode erst clk-sensitiv implementiert
\TODO: maschinenbefehle durchgehen: wurde etwas besonders implementiert?
\TODO: warum zwei Takte?
\TODO: latches
\TODO: synchrones design
\TODO: Register erklären?
\TODO: ALU zero-flag-next entfernen
\fi

\chapter{Umsetzung} % Main chapter title
\label{Umsetzung} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------
\section{Komponenten der CPU}

%\begin{figure}
%
%    \includegraphics[scale=0.3, angle=90]{Figures/dia.jpg}
%\end{figure}


\iffalse
- Diagramm 
- sukzessive Entwicklung, per Maschinenbefehl
\fi
\subsection{Decode}



In dieser Komponente wird der aktuelle Maschinenbefehl, nachdem er aus dem Speicher geladen wurde, dekodiert und die daraus gewonnenen Informationen werden über Steuersignale an die jeweiligen Einheiten der CPU übertragen:
\begin{itemize}
    \item Die \textit{Registerbank} bekommt mitgeteilt, welche Registerinhalte sie an ihre Ausgänge anlegen soll und in welches Register ein potentielles Ergebnis geschrieben werden muss.
        Außerdem wird über einen \textit{Multiplexer} gesteuert, ob dieses Ergebnis vom \textit{Program Counter}, dem \textit{Hauptspeicher} oder der \textit{ALU} zu erwarten ist.
    \item An die \textit{ALU} wird der Operationstyp übermittelt, den diese auf ihre beiden Operanden anwenden soll.
        Zusätzlich wird auch hier ein Multiplexer angesteuert, der der ALU entweder einen Registerinhalt oder eine Konstante als zweiten Operanden zuweist.
    \item Der \textit{Hauptspeicher} erhält Informationen über die Bitbreite und die Art eines Speicherzugriffs (lesend/schreibend).
    \item Der Wert des \textit{Program Counters} muss bei Sprungbefehlen angepasst werden.
\end{itemize}
Es werden also alle Informationen, die zur Ausführung eines Maschinenbefehls nötig sind, von der Dekodiereinheit extrahiert und an die zugehörige Stelle übertragen. 

Bei der Umsetzung dieser Aufgabe erweist sich der Aufbau der Maschinenbefehle als sehr hilfreich:
Vergleichbare Informationen belegen innerhalb der 32-Bit- Instruktionen die gleichen Positionen.
Enthält ein Maschinenbefehl z.B. ein Zielregister in das ein Ergebnis geschrieben werden soll, so befindet sich die Adresse dieses Zielrgisters an der gleichen Position, an der es sich auch bei anderen Befehlen befindet.
Das erleichtert zum einen die Implementierung, da einem Ausgangsport über mehrer Befehle hinweg die gleichen Bits zugeordnet werden können und verringert zum anderen die Komplexität der daraus resultierenden Schaltungen. 
Ein Blick in den Quellcode (siehe~\ref{}) zeigt, dass eine verschachtelte \textit{Case}-Abfrage den Ausgangsports die passenden Signale zuweist, die ohne den vorteilhaften Aufbau der Maschinenbefehle wesentlich komplexer geraten wäre.

\subsection{Program Counter}

Beim sog. \textit{Program Counter} (kurz: \textit{PC}) handelt es sich um ein flankengesteuertes 32-Bit-Register mit asynchronem Reset, das die Adresse enthält, unter der der nächste abzuarbeitende Maschinenbefehl im Hauptspeicher zu finden ist. 
Wie der Name schon vermuten lässt, ist der PC als Zählregister implementiert:
Alle zwei Takte wird der aktuelle Registerwert um vier erhöht, um damit den nächsten 32-Bit-Maschinenbefehl zu adressieren.
Ein Flag (\textit{enable}), das nur alle zwei Takte gesetzt ist, verhindert, dass dieser Vorgang jeden Takt zur Ausführung kommt.

Soll ein Sprungbefehl ausgeführt werden, muss der Wert des PCs auf eine neue Adresse gesetzt oder ein Offset auf den aktuellen Zählerstand addiert werden.
Beide Funktionialitäten wurden direkt im PC implementiert, um einen Umweg über die \textit{ALU} zu vermeiden.
Hierfür stehen die Eingangsports \textit{set}, \textit{set\_value} und \textit{set\_jalr} zur Verfügung.

Am Ausgangsport \textit{value\_out\_next} liegt die Adresse des nächsten Maschinenbefehls (\textit{PC + 4}) an, die als Rücksprungadresse optional in der Registerbank abgespeichert werden kann, um zu einem späteren Zeitpunkt zum ürsprünglichen Ausführungsstrang zurückzukehren.

Die Implementierung des Program Counters unterliegt den Prinzipien des \textit{synchronen Designs} (siehe~\ref{})...

\subsection{Registerbank}

Bevor die CPU eine Rechenoperationen durchführen kann, müssen die passenden Operanden aus dem Hauptspeicher geladen und in der \textit{Registerbank} zwischengespeichert werden.
Diese besteht aus 32 Registern der Länge 32 Bit, wobei es sich bei der vorliegenden Implementierung eigentlich um ein Array aus nur 31 Registern handelt, da das \textit{Register 0} konstant den Wert $0$ enthält und nicht überschrieben werden kann.

Ein asynchroner Leseprozess versorgt die beiden Datenausgänge mit den Inhalten der beiden Register, die durch die Eingänge \textit{rs1} und \textit{rs2} ausgewählt werden.
Beide Ausgänge leiten die Werte an die ALU weiter, während eine zusätzliche Verbindung zum RAM die Ausführung einer \textit{Store}-Instruktion erleichtert.
Ein Schreibprozess in das Register mit dem Index \textit{rd} ist nur bei steigender Taktflanke und gleichzeitig gesetztem Eingangsport \textit{en\_write} möglich, womit ein ungewolltes Speichern verhindert wird.
Der Dateneingang kann mittels eines vorgeschalteten Multiplexers Werte aus den RAM, der ALU oder dem PC empfangen.



\subsection{Arithmetisch Logische Einheit}

Die eigentlichen Rechenoperationen werden in der arithmetisch-logischen Einheit (kurz: \textit{ALU} für \textit{arithmetic logic unit}) durchgeführt.
Wie der Name bereits andeutet, führt diese Einheit arithmetische und logische Funktionen auf zwei 32-Bit-Zahlen aus (siehe Übersicht~\ref{}).
Neben den beiden Dateneingängen enthält die ALU einen weiteren Eingang(\textit{op\_in}), über den sie von der Decode-Einheit den auszuführenden Funktionstypen erhält.
Das Ergebnis der Berechnung wird, abhängig vom Maschinenbefehl, entweder an die Registerbank, den Hauptspeicher oder den Program Counter weitergeleitet.
%TODO: zero_flag
Ein weiterer Ausgangsport (\textit{zero\_flag}) versorgt die Dekodiereinheit bei bedingten Sprungbefehlen mit der Information, ob ein Sprung genommen werden muss. 

Bei der Implementierung wurde eine einfache \textit{Case}-Anweisung verwendet, die den Funktionstypen abfragt, woraufhin die entsprechende Funktion zur Anwendung kommt.

\subsection{Random Access Memory}

Im \textit{RAM} (kurz für: \textit{Random Access Memory}, auch \textit{Hauptspeicher} genannt), werden die Maschinenbefehle und sonstige, zur Programmausführung benötigte Daten, abgelegt.

Grundsätzlich gibt es zwei Arten von RAM, die man implementieren kann:
\textit{Distributed RAM} verwendet die verfügbaren Look-Up-Tables, während es sich beim \textit{Block RAM} um ein internes Speichermodul des FPGAs handelt.
Bei der vorliegenden Implementierung wurde Block RAM initilisiert, wobei allerdings gewisse Design-Pattersn beachtet werden müssen, damit der Baustein bei der Synthese auch als Block RAM erkannt wird.
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------
\section{Entwicklungsumgebung}
\subsection{Vivado}
\subsection{Entwicklungsworkflow}
\subsubsection{Simulation}
\subsubsection{Synthese und Implementierung}
\subsubsection{Deviceprogrammierung}
%----------------------------------------------------------------------------------------


%----------------------------------------------------------------------------------------
\section{Details der Implementierung}
Hier: Erreichte Taktrate, Benötigte Taktzyklen pro
Instruktion, Laufzeiten.. ??
%----------------------------------------------------------------------------------------
