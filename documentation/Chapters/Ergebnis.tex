\chapter{Ergebnis und Ausblick} % Main chapter title
\label{Ergebnis} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------
\section{Kennzahlen}
Die Leistung einer CPU wird in der Regel durch folgende Kennzahlen
dargestellt \cite[S. 43]{Hennessy}:
\begin{itemize}
    \item Schaltfrequenz in MHz \emph{(clock rate)}
    \item Anzahl der CPU-Kerne \emph{(cpu cores)}
    \item Instruktionen pro Clock-Zyklus \emph{(instruction per cycle)} 
\end{itemize}

\paragraph{Schaltfrequenz.} Mit der Entwicklungsumgebung Vivado ist es
möglich herauszufinden wie hoch die Schwaltfrequenz der Clock sein kann,
damit die Implementierung der RISC-V-CPU auf dem vorliegenden FPGA
lauffähig ist. Hierzu sind verschiedene Werte als „Clock Constraint“
getestet worden. Nach der Synthese kann man im Synthese-Report von
Vivado folgenden Ausschnitt beobachten: 
\begin{lstlisting}
Max Delay Paths
---
Slack (MET) :      1.018ns  (required time - arrival time)
  Source:          c_pc/cnt_reg_reg[2]_rep__3/C
  Destination:     c_registerfile/reg_blocks_reg[10][10]/D
  Path Group:      m_clk
  Requirement:     21.277ns  
  Data Path Delay: 20.123ns  
\end{lstlisting}
Als Clock-Constraint wurde $47 MHz \equiv 21.277ns$ angegeben.
Das bedeutet, dass zwischen zwei steigenen Flanken $21.277ns$ vergeht,
dies entspricht einer Schaltfrequenz von $47 MHz$.

Der Synthese-Report zeigt, dass die größte Verzögerung im Design
$20.123ns$ beträgt. Dadurch ist das Design mit $47 MHz$ ($21.277ns$) lauffähig 
.
Bereits bei einer „Clock Constraint“ mit $48 MHz$ wird die Anforderung
überschritten.

Das bedeutet, dass die Implementierung der RISC-V-CPU mit einer Clock
von maximal $\mathbf{47 MHz}$ betrieben werden kann.

\paragraph{CPU-Kerne.} Die umgesetzte CPU besitzt \textbf{einen} Kern.
Eine Parallelausführung von Programmen ist somit nicht möglich.

\paragraph{Instruktionen.} Eine weitere Kennzahl, die die Leistung einer
CPU beschreibt sind die Instruktionen, die pro Clock-Zyklus ausgeführt
werden (IPC). 
In der vorliegenden Implementierung der RISC-V-CPU beträgt \textbf{IPC =
1/2}. Es werden also pro Maschineninstruktion genau \textbf{zwei}
Clock-Zyklen benötigt. Grund hierfür sind die Schreibvorgänge in RAM und
Register. Weitere Informationen hierfür sind in Kapitel
\ref{sec:ram_register_schreibvorgaenge} zu finden.

\section{Ausblick}
%\TODO: einführende Worte

\subsection{Pipelining}

Pipelining ist eine Technik, mit der die Performance einer CPU verbessert werden kann~\cite[A.1]{Hennessy}.
Statt Machineninstruktionen nacheinander auszuführen, werden diese in Teilaufgaben zerlegt, wodurch es möglich ist während eines Taktzyklus Befehle parallel abzuarbeiten.
Die Ausführungszeit eines einzelnen Befehls, also die Taktzahl pro Befehl, kann dadurch länger werden, allerdings ist es möglich insgesamt mehr Instruktionen pro Takt abzuarbeiten.
Klassische Pipeline-Stufen wären z.B.
\begin{itemize}
    \item Instruction fetch - Laden des Maschinenbefehls,
    \item Instruction decode - Dekodieren des Maschinenbefehls,
    \item Execute - Ausführen einer Rechenoperation,
    \item Memory Access - Zugriff auf den Speicher (bei LOAD- und STORE-Befehlen),
    \item Write back - Zurückschreiben des Ergebnisses in den Speicher,
\end{itemize}
aber auch andere Phasen sind denkbar.\\
Um Pipelining umzusetzen, wäre es notwendig die Ergebisse der Teilaufgaben in Register zwischenzuspeichern, um diese der jeweils nächsten Phase zur Verfügung zu stellen





\subsection{Speicherausrichtung}
In Kapitel~\ref{Probleme} wurde erläutert, dass die vorliegende Implementierung nur ausgerichtete Speicherzugriffe unterstützt.
Im Moment werden allerdings keine Vorkehrungen getroffen diese Art Zugriff zu unterbinden oder darauf zu reagieren.
Der entsprechende Maschinenbefehl wird lediglich ignoriert, wodurch ein Programm, das diesen enthält, fehlerhaft ablaufen wird, sollte der nicht ausgerichtete Zugriff nicht schon auf der Kompilerebene unterbunden werden.

Im Rahmen dieser Arbeit wurden zwei Möglichkeiten diskutiert, wie auf Prozessorebene mit diesem Problem umgegangen werden könnte.

\paragraph{Fehler auslösen.}
Eine relative einfache Lösung wäre es, den fehlerhaften Zugriff in irgendeiner Form anzuzeigen und es dem Nutzer zu überlassen den Fehler zu beheben.
Denkbar wäre es hier einen Returncode festzulegen und in diesen 




\iffalse
- den Zugriff auflösen zu Byte-Zugriff -> sehr langsam
- mit compiler von vornherein unterbinden
- return code
\fi


%----------------------------------------------------------------------------------------
