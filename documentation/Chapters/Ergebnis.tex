\chapter{Ergebnis und Ausblick} % Main chapter title
\label{Ergebnis} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------
\section{Kennzahlen}
Die Leistung einer CPU wird in der Regel durch folgende Kennzahlen
dargestellt \cite[S. 43]{Hennessy}:
\begin{itemize}
    \item Schaltfrequenz in MHz \emph{(clock rate)}
    \item Anzahl der CPU-Kerne \emph{(cpu cores)}
    \item Instruktionen pro Clock-Zyklus \emph{(instruction per cycle)} 
\end{itemize}

\paragraph{Schaltfrequenz.} Mit der Entwicklungsumgebung Vivado ist es
möglich herauszufinden wie hoch die Schwaltfrequenz der Clock sein kann,
damit die Implementierung der RISC-V-CPU auf dem vorliegenden FPGA
lauffähig ist. Hierzu sind verschiedene Werte als „Clock Constraint“
getestet worden. Nach der Synthese kann man im Synthese-Report von
Vivado folgenden Ausschnitt beobachten: 
\begin{lstlisting}
Max Delay Paths
---
Slack (MET) :      1.018ns  (required time - arrival time)
  Source:          c_pc/cnt_reg_reg[2]_rep__3/C
  Destination:     c_registerfile/reg_blocks_reg[10][10]/D
  Path Group:      m_clk
  Requirement:     21.277ns  
  Data Path Delay: 20.123ns  
\end{lstlisting}
Als Clock-Constraint wurde $47 MHz \equiv 21.277ns$ angegeben.
Das bedeutet, dass zwischen zwei steigenen Flanken $21.277ns$ vergeht,
dies entspricht einer Schaltfrequenz von $47 MHz$.

Der Synthese-Report zeigt, dass die größte Verzögerung im Design
$20.123ns$ beträgt. Dadurch ist das Design mit $47 MHz$ ($21.277ns$) lauffähig 
.
Bereits bei einer „Clock Constraint“ mit $48 MHz$ wird die Anforderung
überschritten.

Das bedeutet, dass die Implementierung der RISC-V-CPU mit einer Clock
von maximal $\mathbf{47 MHz}$ betrieben werden kann.

\paragraph{CPU-Kerne.} Die umgesetzte CPU besitzt \textbf{einen} Kern.
Eine Parallelausführung von Programmen ist somit nicht möglich.

\paragraph{Instruktionen.} Eine weitere Kennzahl, die die Leistung einer
CPU beschreibt sind die Instruktionen, die pro Clock-Zyklus ausgeführt
werden (IPC). 
In der vorliegenden Implementierung der RISC-V-CPU beträgt \textbf{IPC =
1/2}. Es werden also pro Maschineninstruktion genau \textbf{zwei}
Clock-Zyklen benötigt. Grund hierfür sind die Schreibvorgänge in RAM und
Register. Weitere Informationen hierfür sind in Kapitel
\ref{sec:ram_register_schreibvorgaenge} zu finden.

\section{Ausblick}

Das Ziel dieses Projekts war, einfache Berechnungen auf einer eigenen Hardwareimplementierung ausführen zu können. Dieses Mindestziel wurde erreicht. Darüber hinaus sind jedoch mehrere Ansätze denkbar, das entwickelte CPU-Design fortzuführen. Diese sind unterteilbar in solche, die die Funktionalität erweitern und solche, die das bestehende Design optimieren. Da mit diesem Projekt vor allem Bildungszwecke verfolgt wurden, wurde die Priorität zunächst auf Funktionalitätsaspekte gelegt, anstatt Details des Designs zu zu optimieren.

\subsection{Erweiterungen des Befehlssatz}

Aufgrund der flexiblen Erweiterbarkeit der RISC-V-Architektur (siehe Kapitel \ref{sec:erweiterung} und des modularen Aufbaus dieses Projekts sind zusätzliche Instruktionen, die über den RISC-V Basisbefehlssatz hinausgehen, verhältnismäßig einfach hinzuzufügen. In der RISC-V Spezifikation sind beispielsweise Befehlssatzerweiterungen für Gleitkommaarithmetik, mehrere Privilegierungsebenen, atomare Befehle für Multikernprozessoren, aber auch für Bitmanipulation und Vektoroperationen vorgesehen. \cite[S. 4f.]{RISC} Diese Erweiterungen können je nach indvidueller Anforderungen dem Basisbfehlssatz hinzugefügt werden.
 
Denkbar wäre es außerdem, das CPU-Design über RISC-V Standards hinaus individuell zu erweitern, indem eigene Maschinenbefehle definiert werden, die auf spezielle Anwendungsgebiete zugeschnitten sind.

\subsection{Pipelining}
In der vorliegenden Implementierung wurde aus Zeitgründen auf die Umsetung des sog. Pipelining verzichtet. 
Trotzdem soll hier kurz auf die Grundlagen dieser Technik und deren Voraussetzungen eingegangen werden.
Für eine detaillierte Auseinandersetzung mit diesem Thema wird an dieser Stelle auf weiterführende Literatur verwiesen~\cite[A-2 ff.]{Hennessy}

Pipelining ist ein Verfahren, mit dessen Hilfe die Performance einer CPU verbessert werden kann.
Statt Machineninstruktionen nacheinander auszuführen, werden diese in Teilaufgaben zerlegt, wodurch es möglich ist während eines Taktzyklus Befehle parallel abzuarbeiten.
Die Ausführungszeit eines einzelnen Befehls kann dadurch zwar durchaus länger werden, allerdings ist es möglich insgesamt mehr Instruktionen pro Takt abzuarbeiten.
Klassische Pipeline-Stufen sind z.B.
\begin{itemize}
    \item Instruction fetch - Laden des Maschinenbefehls,
    \item Instruction decode - Dekodieren des Maschinenbefehls,
    \item Execute - Ausführen einer Rechenoperation,
    \item Memory Access - Zugriff auf den Speicher (bei LOAD- und STORE-Befehlen),
    \item Write back - Zurückschreiben des Ergebnisses in den Speicher,
\end{itemize}
aber auch andere Phasen sind denkbar.

Um Pipelining in das vorliegende CPU-Design zu integrieren, wäre es also notwendig die Bearbeitung eines Maschinenbefehls in eindeutig abgegrenzte Stufen zu unterteilen. 
Außerdem müssten die Ergebnisse jeder Stufe in dafür vorgesehene Register zwischengespeichert werden, um diese der jeweils nächsten Phase zur Verfügung zu stellen.

\subsection{Übersetzen von C-Programmen}
Für die vorliegende CPU ist es zwar möglich Assemblerprogramme zu übersetzen und in den RAM zu laden~(\ref{sec:testumgebung}), allerdings muss dabei manuell für die korrekte Anordnung der Daten gesorgt werden.
Aus diesem Grund wurde über die Möglichkeit diskutiert C-Programme zu übersetzen und ohne zusätzliche Vorkehrungen in den Speicher zu laden und auszuführen.
Tatsächlich existiert mit dem RISC-V-GCC\footnote{https://github.com/riscv/riscv-gnu-toolchain (08.03.2017)} bereits ein Compiler für die vorliegende Architektur, allerdings fehlt für das erwähnte Vorhaben eine Ausführungsumgebung (z.B. ein Betriebssystem), die die kompilierte Datei korrekt in den Speicher lädt.

Zwar wurde der naive Versuch unternommen, ein ausführbares C-Programm im ELF-Format (\textit{Executable and Linkable Format}) fast unverändert in den Speicher abzubilden und über kleine Anpassungen den \textit{entry point}, also die Adresse an der die eigentliche Programmausführung beginnt, anzuspringen.
Allerdings folgte relativ schnell die Erkenntnis, dass sich dieses Thema als wesentlich komplexer darstellt als ursprünglich angenommen und damit eine Umsetzung weiterer Recherchen bedarf,~\cite[S. 9 ff.]{elf} auf die im Rahmen dieses Projekts aus Zeitgründen verzichtet wurde.







\subsection{Speicherausrichtung}
In Kapitel~\ref{Probleme} wurde erläutert, dass die vorliegende Implementierung nur ausgerichtete Speicherzugriffe unterstützt.
Im Moment werden allerdings keine Vorkehrungen getroffen diese Art Zugriff zu unterbinden oder darauf zu reagieren.
Der entsprechende Maschinenbefehl wird lediglich ignoriert, wodurch ein Programm, das diesen enthält, fehlerhaft ablaufen wird, sollte der Zugriff nicht schon auf der Kompilerebene unterbunden werden.

Im Rahmen dieser Arbeit wurden zwei Möglichkeiten diskutiert, wie auf Prozessorebene mit diesem Problem umgegangen werden könnte.

\paragraph{Fehler auslösen.}
Eine relative einfache Lösung wäre es, den fehlerhaften Zugriff in irgendeiner Form anzuzeigen und es dem Nutzer zu überlassen den Fehler zu beheben.
Denkbar wäre es hier z.B.  einen Returncode festzulegen und diesen bei einem unerlaubten Zugriff im dafür vorgesehenen Statusregister ??? abzulegen.
Dieser könnte über die LEDs des Nexys-Boards angezeigt werden, um die Information an den Nutzer weiterzugeben.

\paragraph{Zugriff erlauben.} Eine aufwendigere Lösung wäre es, Lese- und Schreiboperationen auf ein nicht ausgerichtetes Datenobjekt grundsätzlich zuzulassen.
Hier könnte man z.B. jeden Zugriff, der mehr als ein Byte breit ist, in eine entsprechende Anzahl von Byte-Zugriffen umwandeln.
So würde 
Dies würde sich natürlich negativ auf die Performance auswirken. 




\iffalse
- den Zugriff auflösen zu Byte-Zugriff -> sehr langsam
- mit compiler von vornherein unterbinden
- return code
\fi


%----------------------------------------------------------------------------------------
